<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LM Studio API Client</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
</head>
<body>
    <div class="sidebar">
        <div class="server-config">
            <input type="text" id="serverUrl" placeholder="URL du serveur" value="http://10.30.3.188:1234">
            <div id="connectionStatus" title="État de la connexion"></div>
        </div>
        <div id="conversations"></div>
    </div>
    
    <div class="main-content">
        <div class="conversation-title-bar" id="currentConversationTitle"></div>
        <div class="chat-container" id="chatHistory"></div>
        
        <div class="input-container">
            <textarea id="chatInput" placeholder="Entrez votre message..." disabled></textarea>
            <div class="controls">
                <button id="sendButton" class="send-button" disabled>Envoyer</button>
                <button id="newConversationButton" class="reset-button">Nouvelle conversation</button>
            </div>
        </div>
    </div>

    <script>
        // Variables globales (restent les mêmes)
        let conversationHistory = [];
        let conversations = [];
        let currentConversationId = null;
        let isGenerating = false;
        let serverUrl = 'http://10.30.3.188:1234';
        let isConnected = false;

        // Toutes les fonctions utilitaires restent les mêmes jusqu'à sendChatMessage

        async function sendChatMessage() {
            const message = document.getElementById('chatInput').value.trim();
            if (!message || isGenerating) return;

            addMessageToHistory(message, 'user');
            disableInput();
            
            const userMessage = {
                role: "user",
                content: message
            };

            conversationHistory.push(userMessage);
            saveCurrentConversation();

            // Créer un div pour la réponse en streaming
            const chatHistory = document.getElementById('chatHistory');
            const responseDiv = document.createElement('div');
            responseDiv.className = 'message assistant-message';
            const markdownContent = document.createElement('div');
            markdownContent.className = 'markdown-content';
            responseDiv.appendChild(markdownContent);
            chatHistory.appendChild(responseDiv);

            let streamedContent = '';

            const payload = {
                messages: conversationHistory,
                model: "local-model",
                temperature: 0.7,
                stream: true  // Activer le streaming
            };

            try {
                const response = await fetch(`${serverUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // Decoder le chunk
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n').filter(line => line.trim() !== '');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonData = line.slice(6);
                            if (jsonData === '[DONE]') continue;

                            try {
                                const data = JSON.parse(jsonData);
                                if (data.choices[0].delta.content) {
                                    const content = data.choices[0].delta.content;
                                    streamedContent += content;
                                    markdownContent.innerHTML = marked.parse(streamedContent);
                                    chatHistory.scrollTop = chatHistory.scrollHeight;
                                }
                            } catch (e) {
                                console.error('Erreur parsing JSON:', e);
                            }
                        }
                    }
                }

                // Sauvegarder le message complet dans l'historique
                const assistantMessage = {
                    role: "assistant",
                    content: streamedContent
                };
                
                conversationHistory.push(assistantMessage);
                saveCurrentConversation();
                updateConnectionStatus(true);
            } catch (error) {
                markdownContent.innerHTML = `Erreur: ${error.message}`;
                updateConnectionStatus(false);
            }

            document.getElementById('chatInput').value = '';
            enableInput();
        }

        // Le reste du code reste le même

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            // L'initialisation reste la même
            loadFromLocalStorage();
            renderConversations();
            
            const chatInput = document.getElementById('chatInput');
            const sendButton = document.getElementById('sendButton');
            const newConversationButton = document.getElementById('newConversationButton');
            const serverUrlInput = document.getElementById('serverUrl');

            chatInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey && !isGenerating) {
                    e.preventDefault();
                    sendChatMessage();
                }
            });

            sendButton.addEventListener('click', sendChatMessage);
            newConversationButton.addEventListener('click', startNewConversation);
            
            serverUrlInput.addEventListener('change', function() {
                serverUrl = this.value;
                saveToLocalStorage();
                checkConnection();
            });

            if (conversations.length > 0) {
                const lastConversation = conversations[conversations.length - 1];
                loadConversation(lastConversation.id);
            } else {
                startNewConversation();
            }

            checkConnection();
            setInterval(checkConnection, 5000);
        });
    </script>
</body>
</html>
