<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LM Studio API Client</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
</head>
<body>
    <div class="sidebar">
        <div class="server-config">
            <input type="text" id="serverUrl" value="http://10.30.3.188:1234">
            <div id="connectionStatus"></div>
        </div>
        <div id="conversations"></div>
    </div>
    
    <div class="main-content">
        <div class="conversation-title-bar" id="currentConversationTitle"></div>
        <div class="chat-container" id="chatHistory"></div>
        <div class="input-container">
            <textarea id="chatInput" placeholder="Entrez votre message..." disabled></textarea>
            <div class="controls">
                <button id="sendButton" disabled>Envoyer</button>
                <button id="newConversationButton">Nouvelle conversation</button>
            </div>
        </div>
    </div>

    <script>
        const state = {
            conversations: JSON.parse(localStorage.getItem('conversations') || '[]'),
            currentId: null,
            history: [],
            isGenerating: false,
            serverUrl: localStorage.getItem('serverUrl') || 'http://10.30.3.188:1234'
        };

        marked.setOptions({ gfm: true, breaks: true });

        const $ = id => document.getElementById(id);
        const save = () => localStorage.setItem('conversations', JSON.stringify(state.conversations));

        async function sendMessage() {
            const input = $('chatInput');
            const message = input.value.trim();
            if (!message || state.isGenerating) return;

            state.isGenerating = true;
            input.value = '';
            input.disabled = true;
            $('sendButton').disabled = true;

            const userMsg = { role: "user", content: message };
            state.history.push(userMsg);
            addMessageToUI(message, 'user');

            try {
                const response = await fetch(`${state.serverUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: state.history,
                        model: "local-model",
                        temperature: 0.7,
                        stream: true
                    })
                });

                const messageDiv = document.createElement('div');
                messageDiv.className = 'message assistant-message';
                const contentDiv = document.createElement('div');
                contentDiv.className = 'markdown-content';
                messageDiv.appendChild(contentDiv);
                $('chatHistory').appendChild(messageDiv);

                let content = '';
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n').filter(line => line.trim());

                    for (const line of lines) {
                        if (line.startsWith('data: ') && line.slice(5) !== '[DONE]') {
                            try {
                                const delta = JSON.parse(line.slice(5)).choices[0].delta.content;
                                if (delta) {
                                    content += delta;
                                    contentDiv.innerHTML = marked.parse(content);
                                    $('chatHistory').scrollTop = $('chatHistory').scrollHeight;
                                }
                            } catch (e) {}
                        }
                    }
                }

                state.history.push({ role: "assistant", content });
                updateConversation();

            } catch (error) {
                addMessageToUI(`Erreur: ${error.message}`, 'assistant');
                updateStatus(false);
            }

            state.isGenerating = false;
            input.disabled = false;
            $('sendButton').disabled = false;
        }

        function addMessageToUI(message, role) {
            const div = document.createElement('div');
            div.className = `message ${role}-message`;
            if (role === 'assistant') {
                const content = document.createElement('div');
                content.className = 'markdown-content';
                content.innerHTML = marked.parse(message);
                div.appendChild(content);
            } else {
                div.textContent = message;
            }
            $('chatHistory').appendChild(div);
            $('chatHistory').scrollTop = $('chatHistory').scrollHeight;
        }

        function updateConversation() {
            const conv = state.conversations.find(c => c.id === state.currentId);
            if (conv) {
                conv.messages = state.history;
                conv.title = conv.title || state.history[0].content.substring(0, 30) + '...';
                save();
                renderConversations();
            }
        }

        function newConversation() {
            state.currentId = 'conv_' + Date.now();
            state.history = [];
            $('chatHistory').innerHTML = '';
            state.conversations.push({
                id: state.currentId,
                date: Date.now(),
                messages: [],
                title: 'Nouvelle conversation'
            });
            save();
            renderConversations();
            $('chatInput').disabled = false;
            $('sendButton').disabled = false;
        }

        function renderConversations() {
            const container = $('conversations');
            container.innerHTML = '';
            state.conversations.forEach(conv => {
                const div = document.createElement('div');
                div.className = `conversation-item${conv.id === state.currentId ? ' active' : ''}`;
                div.innerHTML = `
                    <span class="conversation-title">${conv.title || `Conversation du ${new Date(conv.date).toLocaleString()}`}</span>
                    <div class="conversation-actions">
                        <button onclick="renameConversation('${conv.id}')" class="action-button">Rename</button>
                        <button onclick="deleteConversation('${conv.id}')" class="action-button">Delete</button>
                    </div>
                `;
                div.querySelector('.conversation-title').onclick = () => loadConversation(conv.id);
                container.appendChild(div);
            });
        }

        function loadConversation(id) {
            const conv = state.conversations.find(c => c.id === id);
            if (conv) {
                state.currentId = id;
                state.history = conv.messages;
                $('chatHistory').innerHTML = '';
                conv.messages.forEach(msg => addMessageToUI(msg.content, msg.role));
                renderConversations();
                $('chatInput').disabled = false;
                $('sendButton').disabled = false;
            }
        }

        function renameConversation(id) {
            const conv = state.conversations.find(c => c.id === id);
            if (conv) {
                const title = prompt("Nouveau titre:", conv.title);
                if (title?.trim()) {
                    conv.title = title.trim();
                    save();
                    renderConversations();
                }
            }
        }

        function deleteConversation(id) {
            if (confirm("Supprimer cette conversation ?")) {
                const index = state.conversations.findIndex(c => c.id === id);
                if (index > -1) {
                    state.conversations.splice(index, 1);
                    save();
                    if (id === state.currentId) {
                        if (state.conversations.length) {
                            loadConversation(state.conversations[state.conversations.length - 1].id);
                        } else {
                            newConversation();
                        }
                    }
                    renderConversations();
                }
            }
        }

        async function checkConnection() {
            try {
                const response = await fetch(`${state.serverUrl}/v1/models`);
                updateStatus(response.ok);
            } catch (error) {
                updateStatus(false);
            }
        }

        function updateStatus(connected) {
            const status = $('connectionStatus');
            status.className = connected ? 'connected' : 'disconnected';
            status.title = connected ? 'Connecté' : 'Déconnecté';
            $('chatInput').disabled = !connected;
            $('sendButton').disabled = !connected;
        }

        // Initialisation
        window.onload = () => {
            $('serverUrl').value = state.serverUrl;
            $('sendButton').onclick = sendMessage;
            $('newConversationButton').onclick = newConversation;
            $('serverUrl').onchange = e => {
                state.serverUrl = e.target.value;
                localStorage.setItem('serverUrl', state.serverUrl);
                checkConnection();
            };
            $('chatInput').onkeydown = e => {
                if (e.key === 'Enter' && !e.shiftKey && !state.isGenerating) {
                    e.preventDefault();
                    sendMessage();
                }
            };

            if (state.conversations.length) {
                loadConversation(state.conversations[state.conversations.length - 1].id);
            } else {
                newConversation();
            }

            checkConnection();
            setInterval(checkConnection, 5000);
        };
    </script>
</body>
</html>
